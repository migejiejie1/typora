https://www.cnblogs.com/Soy-technology/p/13109395.html

 

# [**ELK入门及基本使用**](https://www.cnblogs.com/Soy-technology/p/13109395.html)

 

## **预备知识****-Restful**

**起源**

　　在没有前后端分离概念之前，一个网站的完成总是“all in one”，在这个阶段，页面、数据、渲染全部在服务端完成，这样做的最大的弊端是后期维护，扩展极其痛苦，开发人员必须同时具备前后端知识。于是后来慢慢的兴起了前后端分离的思想：即后端负责数据编造，而前端则负责数据渲染，前端静态页面调用指定 api 获取到有固定格式的数据，再将数据展示出来，这样呈现给用户的就是一个”动态“的过程。

　　而关于 api 这部分的设计则成了一个问题。如何设计出一个便于理解，容易使用的 api 则成了一个问题，而所谓的 RESTful 就是用来规范我们的 API 的一种约束。

### **REST**

　　作为 REST，其实是 Representational State Transfer（表象层状态转变）三个单词的缩写，它由 Roy Fielding(Fielding 是 HTTP 协议（1.0 版和 1.1 版）的主要设计者、Apache 服务器软件的作者之一、Apache 基金会的第一任主席)于2000 年论文中提出，他在论文中提到："我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST 指的是一组架构约束条件和原则。"如果一个架构符合 REST 的约束条件和原则，我们就称它为 RESTful 架构。

　　要理解 RESTful 架构，最好的方法就是去理解 Representational StateTransfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。

**资源（Resources）**

REST 的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。

所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。

要让一个资源可以被识别，需要有个唯一标识，在 Web 中这个唯一标识就是URI(Uniform Resource Identifier)。

URI 既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用 URI 来表示，那它就不能算是一个资源，只能算是资源的一些信息而已。

你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。

要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。

所谓"上网"，就是与互联网上一系列的"资源"互动，调用它的 UEI。

 

**URI 设计技巧**

**1、使用 _ 或 - 来让 URI 可读性更好**

曾经 Web 上的 URI 都是冰冷的数字或者无意义的字符串，但现在越来越多的网站使用_或-来分隔一些单词，让 URI 看上去更为人性化。例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格，如

http://www.oschina.net/news/38119/oschina-translate-reward-plan。

**2、使用 / 来表示资源的层级关系**

例如上述/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源，指的是 git 用户的 git 项目的某次提交记录，又例如/orders/2012/10 可以用来表示 2012 年 10 月的订单记录。

**3、使用 ? 用来过滤资源**

很多人只是把?简单的当做是参数的传递，很容易造成 URI 过于复杂、难以理解。可以把?用于对资源的过滤，例如/git/git/pulls 用来表示 git 项目的所有推入请求，而/pulls?state=closed 用来表示 git 项目中已经关闭的推入请求，这种 URL 通常对应的是一些特定条件的查询结果或算法运算结果。

, 或; 可以用来表示同级资源的关系

有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github 可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git

/block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca 作为 URI。不过，现在 github 是使用…来做这个事情的，例如/git/git/compare/master…next。

**4、URI 不应该包含动词**

因为"资源"表示一种实体，所以应该是名词，URI 不应该有动词，动词应该放在 HTTP 协议中。

举例来说，某个 URI 是/posts/show/1，其中 show 是动词，这个 URI 就设计错了，正确的写法应该是/posts/1，然后用 GET 方法表示 show。

如果某些动作是 HTTP 动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户 1向账户 2汇款 500 元，错误的 URI 是：

POST /accounts/1/transfer/500/to/2

正确的写法是把动词 transfer 改成名词 transaction，资源不能是动词，但是可以是一种服务。

**5、URI 中不宜加入版本号**

例如：

http://www.example.com/app/1.0/foo

http://www.example.com/app/1.1/foo

http://www.example.com/app/2.0/foo

 

因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分。

**表现层（Representation）**

　　"资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。

比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG格式表现。

URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI 应该只代表"资源"的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定, 这两个字段才是对"表现层"的描述。

 **状态转化（State Transfer）**

　　访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。

互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。

客户端用到的手段，目前来说只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE 用来删除资源。GET、PUT 和 DELETE 请求都是幂等的，无论对资源操作多少次，结果总是一样的, POST 不是幂等的

# [**get、put、post、delete含义与区别**](https://www.cnblogs.com/luoxuemei/p/9173090.html)

1、GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。

2、PUT请求是向服务器端发送数据的（与GET不同）从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。

3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。

4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。

 就像前面所讲的一样，既然PUT和POST操作都是向服务器端发送数据的，那么两者有什么区别呢。。。POST主要作用在一个集合资源之上的（url），而PUT主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。

综上所述，我们可理解为以下：

1、POST   /url    创建 
2、DELETE  /url/xxx  删除  
3、PUT   /url/xxx  更新
4、GET   /url/xxx  查看

 

**什么是 RESTful 架构**

　　综合上面的解释，我们总结一下什么是 RESTful 架构：

　　1.架构里，每一个 URI 代表一种资源；

　　2.客户端和服务器之间，传递这种资源的某种表现层；

　　3.客户端通过四个 HTTP 动词（get、post、put、delete），对服务器端资源进行操作，实现”表现层状态转化”。

　　注意：REST 架构风格并不是绑定在 HTTP 上，只不过目前 HTTP 是唯一与 REST相关的实例。所以我们这里描述的 REST 也是通过 HTTP 实现的 REST。

 

**辨析 URI、URL、URN**

RFC 3986 中是这样说的：

A Uniform Resource Identifier (URI) 是一个紧凑的字符串用来标示抽象或物理资源。一个 URI 可以进一步被分为定位符、名字或两者都是. 术语“Uniform Resource Locator”(URL) 是 URI 的子集, 除了确定一个资源,还提供一种定位该资源的主要访问机制。

所以，URI = Universal Resource Identifier 统一资源标志符，包含 URL和URN，支持的协议有 http、https、ftp、mailto、magnet、telnet、data、file、nfs、gopher、ldap 等，java 还大量使用了一些非标准的定制模式，如 rmi，jar、jndi 和 doc，来实现各种不同用途。

URL = Universal Resource Locator 统一资源定位符，URL 唯一地标识一个资源在 Internet 上的位置。不管用什么方法表示，只要能定位一个资源，就叫URL。

URN = Universal Resource Name 统一资源名称，URN 它命名资源但不指定如何定位资源，比如：只告诉你一个人的姓名，不告诉你这个人在哪。

对于一个资源来说，URN 就好比他的名字，而 URL 就好比是资源的街道住址。

换句话说，URN 标识了一个资源项目，而 URL 则提供了一种找到他的方法。

比如同时指定基本的获取机制和网络位置。举个例子，

http://example.org/wiki/Main_Page，指向了一个被识别为/wike/Main_Page的资源，这个资源的表现形式是 HTML 和相关的代码。而获取这个资源的方法是在网络中从一个名为 example.org 的主机上，通过 HTTP( Hypertext TransferProtocol)获得。

而 URN 则是一种在特定的名称空间中通过通过名字来标识资源的 URI。当讨论一种资源而不需要知道它的位置或者如何去获得它的时候，就可以使用 URN。

例如，在 International Standard Book Number (ISBN)系统中，* ISBN

0-486-27557-4 用来指定莎士比亚的作品《罗密欧与朱丽叶》的一个特定版本。

指示这一版本的 URN 是 urn:isbn:0-486-27557-4*，但是如果想要获得这个版本的书，就需要知道它的位置，这样就必须知道它的 URL。

 

## **什么是** **ELK**

### **为什么需要** **ELK**

官网的说法：Elasticsearch 是一个开源的分布式 RESTful 搜索和分析引擎，能够解决越来越多不同的应用场景。

看一个应用场景，常见的 WEB 应用日志分析。一般我们会怎么做？

登录到每台服务器上，直接在日志文件中 grep、awk 就可以获得自己想要的信息。但在规模较大的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。

这个时候我们希望集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。

这样对于大型系统来说，都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。

一个完整的集中式日志系统，需要包含以下几个主要特点：

收集－能够采集多种来源的日志数据

传输－能够稳定的把日志数据传输到中央系统

存储－如何存储日志数据分析－可以支持

UI 分析警告－能够提供错误报告，监控机制

ELK就是这样一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用，而不仅仅是日志分析。

## **什么是** **ELK**

ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。

Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。

Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为 c/s 架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往 elasticsearch上去。

Kibana 也是一个开源和免费的工具，Kibana 可以为 Logstash 和

ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。

新增了一个 Beats 系列组件，它是一个轻量级的日志收集处理工具(Agent)，Beats 占用资源少，适合于在各个服务器上搜集日志或信息后传输给 Logstash。

加入 Beats 系列组件后，官方名称就变为了 Elastic Stack，产品如下:

 

![img](../Image/wps1-16654597893791.jpg)

而 Elastic Stack系列产品我们可以到 Elastic的官网上去下载：

https://www.elastic.co/cn/downloads

## **Elasticsearch** **基本原理和概念**

从上面的例子中，我们看到了很多熟悉又陌生的概念，比如索引、文档等等。这些概念和我们平时看到的数据库里的比如索引有什么区别呢？

举个例子，现在我们要保存唐宋诗词，数据库中我们们会怎么设计? 诗词表我们可能的设计如下:

| 朝代 | 作者   | 诗词年代 | 标题   | 诗词全文                                                     |
| ---- | ------ | -------- | ------ | ------------------------------------------------------------ |
| 唐   | 李白   |          | 静夜思 | 床前明月光，疑是地上霜。举头望明月，低头思故乡。             |
| 宋   | 李清照 |          | 如梦令 | 常记溪亭日暮，沉醉不知归路，兴尽晚回舟，误入藕花深处。争渡，争渡，惊起一滩鸥鹭。 |
| ...  | ...    | ...      | ...    | ...                                                          |

要根据朝代或者作者寻找诗，都很简单，比如“select 诗词全文 from 诗词表where作者=‘李白’”，如果数据很多，查询速度很慢，怎么办？我们可以在对应的查询字段上建立索引加速查询。

但是如果我们现在有个需求：要求找到包含“望”字的诗词怎么办？用

“select 诗词全文 from 诗词表 where 诗词全文 like‘%望%’”，这个意味着

要扫描库中的诗词全文字段，逐条比对，找出所有包含关键词“望”字的记录，。

基本上，数据库中一般的 SQL 优化手段都是用不上的。数量少，大概性能还能接受，如果数据量稍微大点，就完全无法接受了，更何况在互联网这种海量数据的情况下呢？

怎么解决这个问题呢，用倒排索引。

### **倒排索引** **Inverted index**

比如现在有：

　　蜀道难（唐）李白 蜀道之难难于上青天，侧身西望长咨嗟。

　　静夜思（唐）李白 举头望明月，低头思故乡。

　　春台望（唐）李隆基 暇景属三春，高台聊四望。

　　鹤冲天 (宋) 柳永 黄金榜上，偶失龙头望。明代暂遗贤，如何向？未遂风云便，争不恣狂荡。何须论得丧？才子词人，自是白衣卿相。烟花巷陌，依约丹青屏障。

　　幸有意中人，堪寻访。且恁偎红翠，风流事，平生畅。青春都一饷。忍把浮名，换了浅斟低唱！

都有望字，于是我们可以这么保存

| 系号 | 关键字 | 蜀道难 | 静夜思 | 春台望 | 鹤冲天 |
| ---- | ------ | ------ | ------ | ------ | ------ |
| 1    | 望     | 有     | 有     | 有     | 有     |
|      |        |        |        |        |        |

如果查哪个诗词中包含上，怎么办，上述的表格可以继续填入新的记录

| 系号 | 关键字 | 蜀道难 | 静夜思 | 春台望 | 鹤冲天 |
| ---- | ------ | ------ | ------ | ------ | ------ |
| 1    | 望     | 有     | 有     | 有     | 有     |
| 2    | 上     | 有     |        |        | 有     |

其实，上述诗词的中每个字都可以作为关键字，然后建立关键字和文档之间的对应关系，也就是标识关键字被哪些文档包含。

所以，倒排索引就是，将文档中包含的关键字全部提取处理，然后再将关键字和文档之间的对应关系保存起来，最后再对关键字本身做索引排序。用户在检索某一个关键字是，先对关键字的索引进行查找，再通过关键字与文档的对应关系找到所在文档。

在存储在关系型数据库中的数据，需要我们事先分析将数据拆分为不同的字段，而在 es 这类的存储中，需要应用程序根据规则自动提取关键字，并形成对应关系。

这些预先提取的关键字，在全文检索领域一般被称为 term（词项），文档的词项提取在 es 中被称为文档分析，这是全文检索很核心的过程，必须要区分哪些是词项，哪些不是，比如很多场景下，apple和 apples 是同一个东西，望和看其实是同一个动作。

## **Elasticsearch** **基本概念**

Elasticsearch 中比较关键的基本概念有索引、文档、映射、映射类型、文档字段概念，为了方便理解，可以和关系数据库中的相关概念进行个比对：

![img](../Image/wps2-16654597893802.jpg)

### **Elasticsearch** **索引**

　　Elasticsearch 索引是映射类型的容器。一个 Elasticsearch 索引非常像关系型世界的数据库，是独立的大量文档集合。

　　当然在底层，肯定用到了倒排索引，最基本的结构就是“keyword(关键字)”和“PostingList(侧排列表倒排列表)”，Posting list就是一个 int的数组，存储了所有符合某个 term(术语)的文档 id。

　　另外，这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。

它会保存每一个词项出现过的文档总数，在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度等等相关信息。

### **文档** **(Document)**

　　文档是 es 中所有可搜索数据的最小单位，比如日志文件中的日志项、一部电影的具体信息等等。

　　文档会被序列化 JSON格式保存到 ElasticSearch 中，JSON 对象由字段组成，每个字段都有对象的字段类型（字符串，数值，布尔，日期，二进制，范围类型）。

　　同时每个文档都有一个 Unique ID，可以自己指定 ID，或者通过 ElasticSearch 自动生成。

　　所以严格来说，es 中存储的文档是一种半结构化的数据。

### **映射**

　　映射（mapping）定义了每个字段的类型、字段所使用的分词器等。

　　get /enjoy_test/_mapping

![img](../Image/wps3-16654597893803.jpg) 

可以显式映射，由我们在索引映射中进行预先定义；也可以动态映射，在添加文档的时候，由 es 自动添加到索引，这个过程不需要事先在索引进行字段数据类型匹配等等，es 会自己推断数据类型。

既然说到了字段类型，当然就离不开字段的数据类型了。

### **文档字段**

文档中的一个字段 field就相当于关系型数据库中的一列 column，那么它肯定有数据类型，es 提供的数据类型包括至少有：

### **数据类型**

**核心数据类型**

\# 字符串类型：string，字符串类还可被分为 text和 keyword 类型，如果我们让 es自动映射数据，那么 es 会把字符串定义为 text，并且还加了一个 keyword类型字段。

text文本数据类型，用于索引全文值的字段。使用文本数据类型的字段，它们会被分词，在索引之前将字符串转换为单个术语的列表(倒排索引)，分词过程允许 ES 搜索每个全文字段中的单个单词。什么情况适合使用 text，只要不具备唯一性的字符串一般都可以使用 text。

keyword，关键字数据类型，用于索引结构化内容的字段。使用 keyword 类型的字段，其不会被分析，给什么值就原封不动地按照这个值索引，所以关键字字段只能按其确切值进行搜索。什么情况下使用 keyword，具有唯一性的字符串，例如：电子邮件地址、MAC 地址、身份证号、状态代码...等等。

\# 数字型数据类型：long、integer、short、byte、double、float

\# 日期类型：date

\# 布尔类型：boolean

**复杂数据类型**

\# 数组：无需专门的数据类型

\# 对象数据类型：单独的 JSON对象

\# 嵌套数据类型：nested，关于 JSON对象的数组

**地理数据类型：**

\# 地理点数据类型

\# 地理形状数据类型

**专门数据类型：**

\# IPv4 数据类型

\# 单词计数数据类型 token_count

## **管理** **Elasticsearch** **索引和文档**

在 es 中，索引和文档是 REST 接口操作的最基本资源，所以对索引和文档的管理也是我们必须要知道的。索引一般是以索引名称出现在 REST请求操作的资源路径上，而文档是以文档 ID 为标识出现在资源路径上。映射类型_doc 也可以认为是一种资源，但在 es7 中废除了映射类型，所以可以_doc 也视为一种接口。

索引的管理

在前面的学习中我们已经知道，GET 用来获取资源，PUT 用来更新资源，DELETE用来删除资源。所以对索引，GET用来查看索引，PUT用来创建索引，DELETE用来删除索引，还有一个 HEAD 请求，用来检验索引是否存在。除此之外，对索引的管理还有

 

列出所有索引

GET /_cat/indices?v

 

关闭索引和打开

POST /open-soft/_close、、

除了删除索引，还可以选择关闭它们。如果关闭了一个索引,就无法通过Elasticsearch来读取和写人其中的数据，直到再次打开它。

在现实世界中，最好永久地保存应用日志，以防要查看很久之前的信息。另一方面，在 Elasticsearch 中存放大量数据需要增加资源。对于这种使用案例，关闭旧的索引非常有意义。你可能并不需要那些数据，但是也不想删除它们。

一旦索引被关闭，它在 Elasticsearch 内存中唯-的痕迹是其元数据，如名字

以及分片的位置。如果有足够的磁盘空间，而且也不确定是否需要在那个数据中再次搜索，关闭索引要比删除索引更好。关闭它们会让你非常安心，永远可以重新打开被关闭的索引，然后在其中再次搜索。

重新打开 POST /open-soft/_open

配置索引

通过 settings参数配置索引，索引的所有配置项都以“index”开头。索引的管理分为静态设置和动态设置两种。

静态设置

只能在索引创建时或在状态为 closed index（闭合索引）上设置，主要配置索引主分片、压缩编码、路由等相关信息

index.number_of_shards主分片数，默认为 5.只能在创建索引时设置，不能修改

index.shard.check_on_startup 是否应在索引打开前检查分片是否损坏，当检查到分片损坏将禁止分片被打开。false：默认值；checksum：检查物理损坏；true:检查物理和逻辑损坏，这将消耗大量内存和 CPU；fix：检查物理和逻辑损坏。

有损坏的分片将被集群自动删除，这可能导致数据丢失

index.routing_partition_size 自定义路由值可以转发的目的分片数。默认为 1，只能在索引创建时设置。此值必须小于 index.number_of_shards

index.codec 默认使用 LZ4压缩方式存储数据，也可以设置为best_compression，它使用 DEFLATE 方式以牺牲字段存储性能为代价来获得更高的压缩比例

动态设置

通过接口“_settings”进行，同时查询配置也通过这个接口进行，比如：get _settings

get /open-soft/_settings

get /open-soft,test1/_settings

配置索引则通过：

put test1/_settings

{

"refresh_interval":"2s"

}

常用的配置参数如下：

index.number_of_replicas 每个主分片的副本数。默认为 1

index.auto_expand_replicas 基于可用节点的数量自动分配副本数量,默认为false（即禁用此功能）

index.refresh_interval 执行刷新操作的频率。默认为 1s。可以设置为 -1 以禁用刷新。

index.max_result_window 用于索引搜索的 from+size 的最大值。默认为10000

index.blocks.read_only 设置为 true 使索引和索引元数据为只读，false 为允许写入和元数据更改。

index.blocks.read 设置为 true 可禁用对索引的读取操作

index.blocks.write 设置为 true 可禁用对索引的写入操作

index.blocks.metadata 设置为 true 可禁用索引元数据的读取和写入

index.max_refresh_listeners 索引的每个分片上可用的最大刷新侦听器数index.max_docvalue_fields_search 一次查询最多包含开启 doc_values 字段

的个数，默认为 100

index.max_script_fields 查询中允许的最大 script_fields数量。默认为 32。

index.max_terms_count 可以在 terms 查询中使用的术语的最大数量。默认为65536。

index.routing.allocation.enable 控制索引分片分配。All(所有分片)、primaries（主分片）、new_primaries（新创建分片）、none（不分片）

index.routing.rebalance.enable 索引的分片重新平衡机制。all、primaries、replicas、none

index.gc_deletes 文档删除后（删除后版本号）还可以存活的周期，默认

为 60s

index.max_regex_length用于正在表达式查询(regex query)正在表达式长度，默认为 1000

**配置映射**

通过_mapping 接口进行，在我们前面的章节中，已经展示过了。

get /open-soft/_mapping

或者只看某个字段的属性：

get /open-soft/_mapping/field/lang

修改映射，当然就是通过 put或者 post方法了。但是要注意，已经存在的映射只能添加字段或者字段的多类型。但是字段创建后就不能删除，大多数参数也不能修改，可以改的是 ignore_above。所以设计索引时要做好规划，至少初始时的必要字段要规划好。

文档的 **id**

当创建文档的时候，如果不指定 ID，系统会自动创建 ID。自动生成的 ID 是一个不会重复的随机数。使用 GUID 算法，可以保证在分布式环境下，不同节点同一时间创建的_id一定是不冲突的

查询文档

get /open-soft/_doc/

 

更新文档

前面我们用 put方法更新了已经存在的文档，但是可以看见他是整体更新文档，如果我们要更新文档中的某个字段怎么办？需要使用_update接口。

```shell
post /open-soft/_update/1/

{

"doc":{

"year": 2016

}

}
```



如果文档中存在 year字段，更新 year 字段的值，如果不存在 year 字段，则会新增 year字段，并将值设为 2016。

update 接口在文档不存在时提示错误，如果希望在文档不存在时创建文档，则可以在请求中添加 upsert参数或 doc_as_upsert 参数,例如:

```shell
POST /open-soft/_update/5

{

"doc": {

"year": "2020"

},

"upsert":{

"name" : "Enjoyedu Framework",

"corp" : "enjoyedu "

}

}

或

 

POST /open-soft/_update/6

{

"doc": {

"year": "2020"

},

"doc_as_upsert" : true

}
```



upsert参数定义了创建新文档使用的文档内容，而 doc_as_upsert 参数的含义是直接使用 doc参数中的内容作为创建文档时使用的文档内容。

 

删除文档

delete /open-soft/_doc/1

## **数据检索和分析**

### **_search** **接口**

所有的 REST搜索请求使用_search 接口，既可以是 GET请求，也可以是 POST请求，也可以通过在搜索 URL 中指定索引来限制范围。

_search 接口有两种请求方法，一种是基于 URI 的请求方式，另一种是基于请求体的方式，无论哪种，他们执行的语法都是基于 DSL（ES 为我们定义的查询语言，基于 JSON的查询语言），只是形式上不同。我们会基于请求体的方式来学习。比如说：

```shell
get kibana_sample_data_flights/_search

{
"query":{
"match_all":{}
}
}

或

get kibana_sample_data_flights/_search

{
"query":{
"match_none":{}
}
}
```



当然上面的查询没什么太多的用处，因为他们分别代表匹配所有和全不匹配。

所以我们经常要使用各种语法来进行查询，一旦选择了要搜索的索引，就需要配置搜索请求中最为重要的模块。这些模块涉及文档返回的数量，选择最佳的文档返回，以及配置不希望哪些文档出现在结果中等等。

■ query-这是搜索请求中最重要的组成部分，它配置了基于评分返回的最佳文档，也包括了你不希望返回哪些文档。

■ size-代表了返回文档的数量。

■ from-和 size 一起使用，from 用于分页操作。需要注意的是，为了确定第2页的 10 项结果，Elasticsearch 必须要计算前 20 个结果。如果结果集合不断增加，获取某些靠后的翻页将会成为代价高昂的操作。

■ _source指定_ source 字段如何返回。默认是返回完整的_ source字段。

通过配置_ source,将过滤返回的字段。如果索引的文档很大，而且无须结果中的全部内容，就使用这个功能。请注意，如果想使用它，就不能在索引映射中关闭_source 字段。

■ sort默认的排序是基于文档的得分。如果并不关心得分，或者期望许多文档的得分相同，添加额外的 sort将帮助你控制哪些文档被返回。

### **结果起始和页面大小**

命名适宜的 from和 size字段，用于指定结果的开始点，以及每“页"结果的数量。举个例子，如果发送的 from 值是 7，size值是 5,那么 Elasticsearch 将返回第8、9、10、11 和 12项结果(由于 from 参数是从 0开始，指定 7 就是从第 8项结果开始)。如果没有发送这两个参数，Elasticsearch 默认从第一项结果开始(第 0 项结果)，在回复中返回 10项结果。

例如

```shell
get kibana_sample_data_flights/_search

{
"from":100,
"size":20,
"query":{
"term":{
"DestCountry":"CN"
}
}
}
```



但是注意，from与 size 的和不能超过 index. max_result_window 这个索引配置项设置的值。默认情况下这个配置项的值为 10000,所以如果要查询 10000 条以后的文档，就必须要增加这个配置值。例如，要检索第 10000 条开始的 200条数据，这个参数的值必须要大于 10200，否则将会抛出类似“Result window is toolarge'的异常。

由此可见，Elasticsearch 在使用 from 和 size处理分页问题时会将所有数据全部取出来，然后再截取用户指定范围的数据返回。所以在查询非常靠后的数据时，即使使用了 from和 size定义的分页机制依然有内存溢出的可能，而 max_result_ window设置的 10000条则是对 Elastiesearch 的一.种保护机制。

那么 Elasticsearch 为什么要这么设计呢?首先，在互联网时代的数据检索应该通过相似度算法，提高检索结果与用户期望的附和度，而不应该让用户在检索结果中自己挑选满意的数据。以互联网搜索为例，用户在浏览搜索结果时很少会看到第 3页以后的内容。假如用户在翻到第 10000 条数据时还没有找到需要的结果，那么他对这个搜索引擎一定会非常失望。

**source** 参数

 

元字段_source 中存储了文档的原始数据。如果请求中没有指定_source，Elasticsearch 默认返回整个_ source，或者如果_ source没有存储，那么就只返回匹配文档的元数据:_ id、_type、_index 和_score。

例如：

```shell
get kibana_sample_data_flights/_search

{
"query":{
"match_all":{}
},
"_source":["OriginCountry","DestCountry"]
}
```



你不仅可以返回字段列表,还可以指定通配符。例如,如果想同时返回"

DestCountry "和" DestWeather "字段，可以这样配置_ source: "Dest*"。也可以使用通配字符串的数组来指定多个通配符，例如_ source:[" Origin*", "* Weather "]。

```shell
get kibana_sample_data_flights/_search

{
"query":{
"match_all":{}
},
"_source":["Origin*","*Weather"]
}
```



不仅可以指定哪些字段需要返回，还可以指定哪些字段无须返回。比如：get kibana_sample_data_flights/_search

```shell
{
"_source":{
"includes":["*.lon","*.lat"],
"excludes":"DestLocation.*"
}
}
```



 

**排序**

大多搜索最后涉及的元素都是结果的排序( sort )。如果没有指定 sort 排序选项，Elasticsearch返回匹配的文档的时候，按照_ score 取值的降序来排列，这样最为相关的(得分最高的)文档就会排名在前。为了对字段进行升序或降序排列，

 

指定映射的数组，而不是字段的数组。通过在 sort 中指定字段列表或者是字段映射,可以在任意数量的字段上进行排序。

 

例如：

 ```shell
 get kibana_sample_data_flights/_search
 
 {
 "from":100,
 "size":20,
 "query":{
 "match_all":{}
 },
 "_source":["Origin*","*Weather"], 
 "sort":[{"DistanceKilometers":"asc"},{"FlightNum":"desc"}]
 }
 ```



 

 

 
