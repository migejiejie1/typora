```shell
一、基本概念

1.1什么是库

在windows平台和linux平台下都大量存在着库。

本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。

由于windows和linux的平台不同（主要是编译器、汇编器和连接器的不同），因此二者库的二进制是不兼容的。

本文仅限于介绍linux下的库。

 

 

1.2库的种类

linux下的库有两种：静态库和共享库（动态库）。

二者的不同点在于代码被载入的时刻不同。

静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。

共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。

 

 

1.3库存在的意义

库是别人写好的现有的，成熟的，可以复用的代码，你可以使用但要记得遵守许可协议。

现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。

共享库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。

 

 

1.4库文件是如何产生的在linux下

静态库的后缀是.a，它的产生分两步

Step 1.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表

Step 2.ar命令将很多.o转换成.a，成为静态库

动态库的后缀是.so，它由gcc加特定参数编译产生。

具体方法参见后文实例。

 

1.5库文件是如何命名的，有没有什么规范

在linux下，库文件一般放在/usr/lib和/lib下，

静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称

动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号， minor是副版本号

 

 

1.6如何知道一个可执行程序依赖哪些库

ldd命令可以查看一个可执行程序依赖的共享库，

例如# ldd /bin/lnlibc.so.6

=> /lib/libc.so.6 (0×40021000)/lib/ld-linux.so.2

=> /lib/ld- linux.so.2 (0×40000000)

可以看到ln命令依赖于libc库和ld-linux库

 

 

1.7可执行程序在执行的时候如何定位共享库文件

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。

此时就需要系统动态载入器(dynamic linker/loader)

对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib目录找到库文件后将其载入内存

如：export LD_LIBRARY_PATH=’pwd’

将当前文件目录添加为共享目录

 

1.8在新安装一个库之后如何让系统能够找到他

如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。

如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下

1.编辑/etc/ld.so.conf文件，加入库文件所在目录的路径

2.运行ldconfig，该命令会重建/etc/ld.so.cache文件

 
```

